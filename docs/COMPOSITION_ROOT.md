# Composition Root

The place where you compose an application from many loosely coupled components it's called the Composition Root.
Many components may lead to a huge Composition Root that can be a tough nut to maintain manually.

Let's consider the following example. We work on an HTTP server with couple of endpoints, e.g.:

```go

import (
	nethttp "net/http"
	httpPkg "project/http"
)


serveMux := nethttp.NewServeMux()
serveMux.Handle("/user", httpPkg.NewUserHandler())
serveMux.Handle("/order", httpPkg.NewOrderHandler())
// more endpoints

server := nethttp.Server{
    Addr:    ":8080",
    Handler: serveMux,
}
```

Some endpoints may need additional dependencies, e.g.:

```go
l := logger.New()
db := sql.New(l)
userRepository := user.NewRepository(db)
userHandler := http.NewUserHandler(userRepository)
serveMux.Handle("/user", userHandler)
```

In the time it can be desired decorating endpoints, e.g.:

```go
l := logger.New()
db := sql.New(l)
userRepository := user.NewRepository(db)
userHandler := http.NewLogExecutionTimeEndpoint(
    http.http.NewLoggableEndpoint(
        http.NewUserHandler(userRepository, l),
    ),
)
serveMux.Handle("/user", userHandler)
```

When your application has more than only a few components we may end up with a huge file where we manually wire all components.

Instead of compositing all components manually,
we may define a configuration file where we tell our DI container which components need which dependencies, e.g.:

```yaml
services:
  serveMux:
    constructor: '"net/http".NewServeMux'
    calls:
      - [ "Handle", [ "/user", "@userHandler" ] ]
    
  server:
    value: '&"net/http".Server{}'
    getter: "GetServer"
    must_getter: true
    fields:
      Addr: ":8080"
      Handler: "@serveMux" # inject serveMux object

  logger:
    constructor: "logger.New"

  db:
    constructor: "sql.New"
    args: ["@logger"]

  userRepository:
    constructor: "user.NewRepository"
    args: ["@db"]

  userHandler:
    constructor: '"project/http".NewUserHandler'
    args: ["@userRepository", "@logger"]
    tags: ["http.endpoint"]

decorators:
  - tag: "http.endpoint" # decorate all services tagged by "http.endpoint"
    decorator: "decorators.EndpointWithLogger"
    args: ["@logger"]

  - tag: "http.endpoint" # decorate all services tagged by "http.endpoint"
    decorator: "decorators.EndpointWithExecutionTime"
    args: ["@logger"]
```

Even though the configuration may seem to be quite big, we will notice the benefit when we will use autogenerated code:

```go
g := NewGontainer()
s := c.MustGetServer()

err := s.ListenAndServe()
if err != nil {
    panic(err)
}
```
